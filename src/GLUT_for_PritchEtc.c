#define UN_EXTERN#include <stdio.h>#include <stdlib.h>#include <string.h>#include "ECA_MemAlloc.h"#include "MCTypesEtc.h"#include "MathStatRand.h"#include "ranlib.h"#include "GFMCMC.h"#include "GFMCMC_DrawingUtilities.h"#include "NewHybrids.h"#include "GLUT_for_PritchEtc.h"#include "MAZ4NewHybs.h"// some menu identifiers#define ALLELE_RIGHT_CLICK 0#define PRITCHQ_RIGHT_CLICK 1// a global variable to record the max number of alleles at any locusGLOB int gMaxAlleNum;GLOB char **gAlleStrings;// a global variable to record the sort order for Kullback-LeiblerGLOB int *gLocusSortArray;GLOB char **gPureVsAdmixedStrings;GLOB char **gGenePoolNameStrings;GLOB int gTwo;/*		THESE ARE OUR MANDATORY FUNCTION DEFINITIONS.  THE PROTOTYPES	ARE FOUND IN GLUT_FOR_MCMC.h 		Here we must give definitions for:		void gfmUserDefd_ResetAllAverages(void)	void gfmUserDefd_InitializeChain(void)	void OneStepByGlobals(void)	*/void gfmUserDefd_ResetAllAverages(void){	PritchResetAllAveragesEtc(gC);	gNumSweepsAfterBurnIn = 0;	}void gfmUserDefd_InitializeChain(void){	InitializePritchVars(gC);	gNumSweeps = 0;	}void gfmUserDefd_OneStepByGlobals(void){			PritchSingleSweep(gC);		IncrementPritchVars(gC,1);		/*		if(gNumSweeps%25==0) {			printf("\nLogL = %f",gC->Lat->CompleteDataLogLike->Trace[20]);			printf("\n%d:  ",gNumSweeps);		}*/		}// this is the function that defines what all the windows are//#define gfnhCAT_PROBS_SETUP gsDRAW_FUNC(gfnhDrawCategoryProbs); gsNUM_COLOR_KEYS( &(gC->Dat->Gn->v)); gsCOLOR_KEYS(gC->Dat->CategoryNames); gsMIDDLE_CLICK_MENU(CATEGORY_RIGHT_CLICK); gsCOLOR_SCHEME(OL_GRAYBACK);#define gfnhALLELE_FREQ_SETUP gsDRAW_FUNC(gfnhDrawAlleleFreqs); gsNUM_COLOR_KEYS( &(gMaxAlleNum)); gsCOLOR_KEYS(gAlleStrings); gsMIDDLE_CLICK_MENU(ALLELE_RIGHT_CLICK); gsCOLOR_SCHEME(FISHER_PRICE);void gfmUserDefd_DefineWindows(void){	int l;	// before getting down with it, here I compute the max num of alleles at any locus	// and also make a string that says "Allele 1" etc.	gMaxAlleNum = 0;	CYCLE_l(gC->Dat)		if(gC->Dat->Kl[l] > gMaxAlleNum)			gMaxAlleNum = gC->Dat->Kl[l];	END1CYCLE		// now make the strings	gAlleStrings = (char **)ECA_CALLOC((size_t)gMaxAlleNum,sizeof(char *));	for(l=0;l<gMaxAlleNum;l++)  {		gAlleStrings[l] = (char *)ECA_CALLOC(30,sizeof(char));		sprintf(gAlleStrings[l],"Allele %d",l+1);	}		gPureVsAdmixedStrings = (char **)ECA_CALLOC((size_t)2,sizeof(char *)); 	for(l=0;l<2;l++)  {		gPureVsAdmixedStrings[l] = (char *)ECA_CALLOC((size_t)30,sizeof(char ));		if(l==0)			sprintf(gPureVsAdmixedStrings[l],"PURE");		else 			sprintf(gPureVsAdmixedStrings[l],"ADMIXED");	}	gTwo = 2;		gGenePoolNameStrings = (char **)ECA_CALLOC((size_t)2,sizeof(char *)); 	for(l=0;l<gC->Lat->PritLat->NumSources->v;l++)  {		gGenePoolNameStrings[l] = (char *)ECA_CALLOC((size_t)30,sizeof(char ));				sprintf(gGenePoolNameStrings[l],"GenePool %d",l);	}			gsOUTPUT_FILE_PREFIX("PritchEtc");			// go ahead and do the definitions:	gsCONSOLE("\"Info\" Window");		gsDRAW_FUNC(gfnhDrawConsoleWindow);				gsNEW_WINDOW(1,"Current Allele Freqs");		gfnhALLELE_FREQ_SETUP		gsSET(GFNH_CURRENT_OR_AVES, GFNH_CURRENT);			gsNEW_WINDOW(3,"Average Allele Freqs");		gfnhALLELE_FREQ_SETUP		gsSET(GFNH_CURRENT_OR_AVES, GFNH_AVES);			gsNEW_WINDOW(4,"Allele Frequency Histogram");		gsDRAW_FUNC(gfnhDrawAlleleFreqsHist);		gsCOLOR_KEYS(gAlleStrings);		gsCOLOR_SCHEME(FISHER_PRICE);		gsAXES_POS_UNIT_X;		// note that NumColorKeys gets set depending on the Displayed Locus from		// within the function gfnhDrawAlleleFreqsHist()					gsNEW_WINDOW(5,"Observed Data");		gsDRAW_FUNC(gfnhDrawObservedData);		gsCOLOR_SCHEME(FISHER_PRICE);		gsXLO(-.15f * (GLfloat)gC->Dat->L);		gsXHI(1.15f * (GLfloat)gC->Dat->L);		gsYLO(-.15f * 3.0f * (GLfloat)gC->Dat->M);		gsYHI(1.15f * 3.0f * (GLfloat)gC->Dat->M);				gsPADDING(-.17,1.17,-.17,1.17);			gsNEW_WINDOW(6,"Complete Data LogL Trace");		gsDRAW_FUNC(gfnhDrawCompleteDataLogLTrace);		gsCOLOR_SCHEME(OL_GRAYBACK);			gsNEW_WINDOW(7,"Current Kullback Leibler Info By Locus")		gsDRAW_FUNC(gfnhDrawKullbLeib);		gsXLO(-.15 * 12.0f);		gsXHI(1.15 * 12.0f);		gsYLO(-.15f * (GLfloat)gC->Dat->L);		gsYHI(1.15f * (GLfloat)gC->Dat->L);		gsCOLOR_SCHEME(OL_GRAYBACK);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_CURRENT);		gsAXES_POS_QUADRANT		gsNO_Y_AXIS			gsNEW_WINDOW(8,"Average Kullback Leibler Info By Locus")		gsDRAW_FUNC(gfnhDrawKullbLeib);		gsXLO(-.15 * 12.0f);		gsXHI(1.15 * 12.0f);		gsYLO(-.15f * (GLfloat)gC->Dat->L);		gsYHI(1.15f * (GLfloat)gC->Dat->L);		gsCOLOR_SCHEME(OL_GRAYBACK);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_AVES);		gsAXES_POS_QUADRANT		gsNO_Y_AXIS	gsNEW_WINDOW(9,"Current Pritchard Q");		gsDRAW_FUNC(gfnhDrawPritchardQs);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_CURRENT);		gsMIDDLE_CLICK_MENU(PRITCHQ_RIGHT_CLICK);		gsCOLOR_SCHEME(DEEP_BLUE);		gsNUM_COLOR_KEYS(&gC->Lat->PritLat->NumSources->v);		gsCOLOR_KEYS(gGenePoolNameStrings);			gsNEW_WINDOW(10,"Average Pritchard Q");		gsDRAW_FUNC(gfnhDrawPritchardQs);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_AVES);		gsMIDDLE_CLICK_MENU(PRITCHQ_RIGHT_CLICK)		gsCOLOR_SCHEME(DEEP_BLUE);		gsNUM_COLOR_KEYS(&gC->Lat->PritLat->NumSources->v);		gsCOLOR_KEYS(gGenePoolNameStrings);			gsNEW_WINDOW(11,"Alpha Histograms");		gsDRAW_FUNC(gfpeDrawAlphaHists);		gsAXES_POS_QUADRANT		gsCOLOR_SCHEME(DEEP_BLUE);		gsXHI( 1.1f * gC->Lat->PritLat->MaxAlpha[0]->v);		gsNUM_COLOR_KEYS(&gC->Lat->PritLat->NumSources->v);		gsCOLOR_KEYS(gGenePoolNameStrings);					gsNEW_WINDOW(12,"Indiv Q Histogram");		gsDRAW_FUNC(gfpeDrawPritchQHist);		//gsCOLOR_KEYS(gC->Dat->CategoryNames);		//gsNUM_COLOR_KEYS(&(gC->Dat->Gn->v));		gsCOLOR_SCHEME(OL_GRAYBACK);		gsAXES_POS_UNIT_X;		gsNUM_COLOR_KEYS(&gC->Lat->PritLat->NumSources->v);		gsCOLOR_KEYS(gGenePoolNameStrings);			gsNEW_WINDOW(13, "Xi Histogram")		gsDRAW_FUNC(gfpeDrawXiHists);		gsAXES_POS_QUADRANT;		gsCOLOR_SCHEME(OL_GRAYBACK);		gsNUM_COLOR_KEYS(&gTwo);		gsCOLOR_KEYS(gPureVsAdmixedStrings);			gsNEW_WINDOW(14, "Pi Histogram")		gsDRAW_FUNC(gfpeDrawPiHists);		gsAXES_POS_QUADRANT;		gsCOLOR_SCHEME(DEEP_BLUE);		gsNUM_COLOR_KEYS(&gC->Lat->PritLat->NumSources->v);		gsCOLOR_KEYS(gGenePoolNameStrings);			gsNEW_WINDOW(15,"Current Prob Pure versus Admixed");		gsDRAW_FUNC(gfpehDrawPofV);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_CURRENT);		gsMIDDLE_CLICK_MENU(PRITCHQ_RIGHT_CLICK);		gsCOLOR_SCHEME(OL_GRAYBACK);		gsNUM_COLOR_KEYS(&gTwo);		gsCOLOR_KEYS(gPureVsAdmixedStrings);		gsNEW_WINDOW(16,"Average Prob Pure versus Admixed");		gsDRAW_FUNC(gfpehDrawPofV);		gsSET(GFNH_CURRENT_OR_AVES, GFNH_AVES);		gsMIDDLE_CLICK_MENU(PRITCHQ_RIGHT_CLICK);		gsCOLOR_SCHEME(OL_GRAYBACK);		gsNUM_COLOR_KEYS(&gTwo);		gsCOLOR_KEYS(gPureVsAdmixedStrings);}void gfmUserDefd_DefineMenus(void){	gUserDefdMenus[ALLELE_RIGHT_CLICK] = glutCreateMenu(gfnhOpenAlleleRightClickWindow);	glutAddMenuEntry("Open Histogram View For Selected Locus", 4);	gUserDefdMenus[PRITCHQ_RIGHT_CLICK] = glutCreateMenu(gfnhOpenPritchQRightClickWindow);	glutAddMenuEntry("Open Histogram View of Q Selected Individual", 0);}// this is a place that a user can do some last minute things like // make some new menus and the like.  Here I don't have anything to do.void gfmUserDefd_LastWords(void){	return;}void gfnhDrawConsoleWindow(void){	char temp[250];		glColor3fv(gWindowsSettings[glutGetWindow()]->ColorScheme->Text);	gfmRenderBitmapString(-.1f,1.0f,GLUT_BITMAP_HELVETICA_12, "Program: PritchEtc");	gfmRenderBitmapString(-.1f,.9f,GLUT_BITMAP_HELVETICA_12, "Author: E.C. Anderson");		sprintf(temp,"Data: \"%s\"", gC->Dat->DataFileName);	gfmRenderBitmapString(-.1f,.8f,GLUT_BITMAP_HELVETICA_12, temp);		sprintf(temp,"%d Sweeps",gNumSweeps);	gfmRenderBitmapString(-.1f,.7f,GLUT_BITMAP_HELVETICA_12, temp);		sprintf(temp,"%d After Burn In",gNumSweepsAfterBurnIn);	gfmRenderBitmapString(-.1f,.6f,GLUT_BITMAP_HELVETICA_12, temp);		if(gGo) 		sprintf(temp,"RUNNING!",gNumSweepsAfterBurnIn);	else 		sprintf(temp,"STOPPED!",gNumSweepsAfterBurnIn);			gfmRenderBitmapString(-.1f,.5f,GLUT_BITMAP_HELVETICA_12, temp);		}// draws histograms of each of the alphas, uses different colors for the different// sourcesvoid gfpeDrawAlphaHists(void){	int s,i;	double Ymax = 0.0, Ymin = 9999999.99;	gsDECLARE_CURRENT_WINDOW_VARS		CYCLE_s(gC->Lat->PritLat)		glColor3fv(CS->Series[s]);		gfmduDrawOneHistAsCurveWith2Bars(gC->Lat->PritLat->Alpha[s],0,GFMDU_NO_STIPPLE,0);	END1CYCLE		// then draw the axes	gfmDrawXYAxes();		// deal with the extrema	CYCLE_s(gC->Lat->PritLat)		for(i=0;i<gC->Lat->PritLat->Alpha[s]->Hist->NumBins;i++)  {			if(Ymax < gC->Lat->PritLat->Alpha[s]->Hist->H[i])				Ymax < gC->Lat->PritLat->Alpha[s]->Hist->H[i];			if(Ymin > gC->Lat->PritLat->Alpha[s]->Hist->H[i])				Ymin < gC->Lat->PritLat->Alpha[s]->Hist->H[i];		}	END1CYCLE	}// draws histograms of each of the Xi's, uses different colors for JA_PURE and JA_ADMIXEDvoid gfpeDrawXiHists(void){	int jv;	double Ymax = 0.0, Ymin = 9999999.99;	gsDECLARE_CURRENT_WINDOW_VARS		CYCLE_jv		glColor3fv(CS->Series[jv]);		gfmduDrawOneHistAsCurveWith2Bars(gC->Lat->PritLat->Xi[jv],1,GFMDU_NO_STIPPLE,0);	END1CYCLE		// then draw the axes	gfmDrawXYAxes();	}// draws histograms of each of the Pi's, uses different colors for JA_PURE and JA_ADMIXEDvoid gfpeDrawPiHists(void){	int jv;	double Ymax = 0.0, Ymin = 9999999.99;	gsDECLARE_CURRENT_WINDOW_VARS		CYCLE_jv		glColor3fv(CS->Series[jv]);		gfmduDrawOneHistAsCurveWith2Bars(gC->Lat->Pi[jv],1,GFMDU_NO_STIPPLE,0);	END1CYCLE		// then draw the axes	gfmDrawXYAxes();	}void gfnhDrawKullbLeib(void){	int l;	GLfloat x=0.0f,y,h=.7f,w,max=0.0f;	char S[100];	gsDECLARE_CURRENT_WINDOW_VARS	FILE *out;			CYCLE_l(gC->Dat)		//set the height and the width		y = (GLfloat)(gC->Dat->L - l);				if(Settings->GFNH_CURRENT_OR_AVES == GFNH_AVES)			w = (GLfloat)gC->Lat->Locus_KB[l]->Ave;		else if(Settings->GFNH_CURRENT_OR_AVES == GFNH_CURRENT)			w = (GLfloat)gC->Lat->Locus_KB[l]->v;		else {			out = fopen("ErrorFile","a");			fprintf(out,"\nGFNH_CURRENT_OR_AVES set to neither GFNH_AVES or");			fprintf(out,"\nGFNH_CURRENT in gfnhDrawKullbLeib!! \n\n");			fclose(out);		}		if(w>max)			max = w;				// set the string of the locus and print it		sprintf(S,"%s ",gC->Dat->LocNames[l]);		glColor3fv(CS->Text);		gfmStrokeString(S, h*.85f ,x, y-h, 4, 0.0f, WoH);				// then print the rectangle in the 3rd color of the series		glColor3fv(CS->Series[5]);		glRectf(x,y,x+w,y-h);	END1CYCLE		gsHANDLE_EXTREMA(0,max,0,gC->Dat->L);		gfmDrawXYAxes();}void gfnhDrawCompleteDataLogLTrace(void){	int CW = glutGetWindow();		glColor3fv(gWindowsSettings[glutGetWindow()]->ColorScheme->Series[0]);	fitting_struct *Fits  = gWindowsSettings[CW]->Fits;		//	gfduDrawSlidingTrace(gC->Lat->CompleteDataLogLike);		gfmDrawXYAxes();}// draw the data as two rows for each individual.  Each gene copy fits into// a unit square (which may get stretched) and will be color coded.  Blank// squares of the axis color denote missing data.// Horizontal lines between the individuals are toggled using the Xaxis DrawIt variablevoid gfnhDrawObservedData(void){	int i,l,c;	GLfloat xs = .8f, ys = .8f;	GLfloat x,y, yy;	ColorScheme3f *CS = gWindowsSettings[glutGetWindow()]->ColorScheme;	XY_axis_struct *XA = gWindowsSettings[glutGetWindow()]->Xaxis;	clipping_struct *C = gWindowsSettings[glutGetWindow()]->Clips;	GLfloat WoH = gfmWoH();	char temp[100];	GLfloat texth;		// lay down the locus names as rotated text at the top of each column	// set the top height of the bars	y = 3.0f * (GLfloat)gC->Dat->M;	texth = xs * (C->yhi - C->ylo) / (C->xhi - C->xlo) ;  // for textheight	CYCLE_l(gC->Dat)  // cycle over the loci		x = (GLfloat)l;  // set the "cursor" to the left edge of each locus rectangle				sprintf(temp," %s",gC->Dat->LocNames[l]);		glColor3fv(CS->Text);		gfmStrokeString(temp,texth,x+.5f*xs,y,1,-45.0f,WoH);	END1CYCLE			CYCLE_i(gC->Dat)		y = 3.0f * (GLfloat)gC->Dat->M - (3.0f * (GLfloat)i);				// draw text telling the individual's number		glColor3fv(CS->Text);		sprintf(temp,"%d",i+1);				gfmStrokeString(temp, 1.9f ,-.1f, y-1.8f, 4, 0.0f,WoH);		CYCLE_l(gC->Dat)			x = (GLfloat)l;			yy = y;			if(gC->Dat->LocTypes[l] == CODOM) { // draw alleles if they are codominant				for(c=0;c<2;c++)  {					if(gC->Dat->Yobs[i][l][c]->v >= 0)  {  // if it is not missing data draw the square						glColor3fv(CS->Series[gC->Dat->Yobs[i][l][c]->v % CS->N]);  // set the color						glRectf(x,yy,x+xs,yy-ys);					}					else {  // if it is missing, then draw an empty box in axis color						glColor3fv(CS->Axes);  // set the color						glBegin(GL_LINE_LOOP);							glVertex2f(x,yy);							glVertex2f(x+xs,yy);							glVertex2f(x+xs,yy-ys);							glVertex2f(x,yy-ys);						glEnd();					}					// move the second allele down one unit:					yy -= 1.0f;				}			}			// now, if the locus is an AFLP locus, we draw a plus or a zero			if(gC->Dat->LocTypes[l] == AFLP) {				if(gC->Dat->Yobs[i][l][0]->v == 1)  {					sprintf(temp,"+");					glColor3fv(CS->Series[0]);					gfmStrokeString(temp,3.0f,x + (.5f * xs),y-2.4f + .3f * ys, 2,0.0f,WoH);				}				else  {					sprintf(temp,"0");					glColor3fv(CS->Series[1]);					gfmStrokeString(temp,2.2f,x + (.5f * xs),y-2.2f + .3f * ys, 2,0.0f,WoH);				}																}		END1CYCLE				// draw a separating line 		if(XA->DrawIt==1)  {			glColor3fv(CS->Axes);			glBegin(GL_LINES);				glVertex2f(0.0f,y-2.5f);				glVertex2f((GLfloat)gC->Dat->L-(1.0f-xs),y-2.5f);			glEnd();		}				END1CYCLE		gsHANDLE_EXTREMA(0.0f,(GLfloat)gC->Dat->L,0.0f, 3.0f * (GLfloat)gC->Dat->M);		}void gfnhDrawCategoryProbs(void){	int i,g;	GLfloat xs = .5f, ys = .5f;	int n;	GLfloat w,h;	GLfloat x, y;	int Aves = 0;	GLfloat cum;	int CW = glutGetWindow();	char temp[200];	GLfloat WoH = gfmWoH();	if(gWindowsSettings[CW]->GFNH_CURRENT_OR_AVES==GFNH_AVES)		Aves = 1;		gfmSetParsForBarGraphs(gC->Dat->M, gWindowsSettings[CW]->NumCols, xs, ys, &n, &w, &h);		gWindowsSettings[CW]->SelectedElement = gfmBarGraphIdxFromXY(n, gC->Dat->M,  w,  h,  xs,  ys,					 gWindowsSettings[CW]->XCoord,  gWindowsSettings[CW]->YCoord);		CYCLE_i(gC->Dat)		cum = 0.0f;		x = gfmBarGraphXCoord(n,w,xs,i);		y = gfmBarGraphYCoord(n,h,ys,i);				// draw a text label just to the left of the bar, too, with height equal to height of		// the bar, and moved just left of it (by half of a space character		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		sprintf(temp,"%d ",i+1);		gfmStrokeString(temp, h ,x, y-h, 3, 0.0f,WoH);				CYCLE_g(gC->Lat)						gfmDrawRectLeaf6f(x,y,w,h, cum, 1.0f, gWindowsSettings[CW]->ColorScheme->Series[g]);									if(Aves)				cum += (GLfloat)gC->Lat->Ind[i]->PofZ[g]->Ave;			else				cum += (GLfloat)gC->Lat->Ind[i]->PofZ[g]->v;				END1CYCLE	END1CYCLE		if(gWindowsSettings[CW]->SelectedElement >= 0) {		sprintf(temp,"Selected Individual = %d", gWindowsSettings[CW]->SelectedElement+1);		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		gfmRenderBitmapString(-.05f,1.1f,GLUT_BITMAP_HELVETICA_12,temp);	}}void gfnhDrawPritchardQs(void){	int i,s;	GLfloat xs = .5f, ys = .5f;	int n;	GLfloat w,h;	GLfloat x, y;	int Aves = 0;	GLfloat cum;	int CW = glutGetWindow();	char temp[200];	GLfloat WoH = gfmWoH();	if(gWindowsSettings[CW]->GFNH_CURRENT_OR_AVES==GFNH_AVES)		Aves = 1;		gfmSetParsForBarGraphs(gC->Dat->M, gWindowsSettings[CW]->NumCols, xs, ys, &n, &w, &h);		gWindowsSettings[CW]->SelectedElement = gfmBarGraphIdxFromXY(n, gC->Dat->M,  w,  h,  xs,  ys,					 gWindowsSettings[CW]->XCoord,  gWindowsSettings[CW]->YCoord);		CYCLE_i(gC->Dat)		cum = 0.0f;		x = gfmBarGraphXCoord(n,w,xs,i);		y = gfmBarGraphYCoord(n,h,ys,i);				// draw a text label just to the left of the bar, too, with height equal to height of		// the bar, and moved just left of it (by half of a space character		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		sprintf(temp,"%d ",i+1);		gfmStrokeString(temp, h ,x, y-h, 3, 0.0f,WoH);				CYCLE_s(gC->Lat->PritLat)						gfmDrawRectLeaf6f(x,y,w,h, cum, 1.0f, gWindowsSettings[CW]->ColorScheme->Series[s]);									if(Aves)				cum += (GLfloat)gC->Lat->Ind[i]->PritInd->Q[s]->Ave;			else				cum += (GLfloat)gC->Lat->Ind[i]->PritInd->Q[s]->v;				END1CYCLE	END1CYCLE		if(gWindowsSettings[CW]->SelectedElement >= 0) {		sprintf(temp,"Selected Individual = %d", gWindowsSettings[CW]->SelectedElement+1);		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		gfmRenderBitmapString(-.05f,1.1f,GLUT_BITMAP_HELVETICA_12,temp);	}}void gfpehDrawPofV(void){	int i,s;	GLfloat xs = .5f, ys = .5f;	int n;	GLfloat w,h;	GLfloat x, y;	int Aves = 0;	GLfloat cum;	int CW = glutGetWindow();	char temp[200];	GLfloat WoH = gfmWoH();	if(gWindowsSettings[CW]->GFNH_CURRENT_OR_AVES==GFNH_AVES)		Aves = 1;		gfmSetParsForBarGraphs(gC->Dat->M, gWindowsSettings[CW]->NumCols, xs, ys, &n, &w, &h);		gWindowsSettings[CW]->SelectedElement = gfmBarGraphIdxFromXY(n, gC->Dat->M,  w,  h,  xs,  ys,					 gWindowsSettings[CW]->XCoord,  gWindowsSettings[CW]->YCoord);		CYCLE_i(gC->Dat)		cum = 0.0f;		x = gfmBarGraphXCoord(n,w,xs,i);		y = gfmBarGraphYCoord(n,h,ys,i);				// draw a text label just to the left of the bar, too, with height equal to height of		// the bar, and moved just left of it (by half of a space character		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		sprintf(temp,"%d ",i+1);		gfmStrokeString(temp, h ,x, y-h, 3, 0.0f,WoH);				for(s=0;s<2;s++)  {						gfmDrawRectLeaf6f(x,y,w,h, cum, 1.0f, gWindowsSettings[CW]->ColorScheme->Series[s]);									if(Aves)				cum += (GLfloat)gC->Lat->Ind[i]->PritInd->PofV[s]->Ave;			else				cum += (GLfloat)gC->Lat->Ind[i]->PritInd->PofV[s]->v;				}	END1CYCLE		if(gWindowsSettings[CW]->SelectedElement >= 0) {		sprintf(temp,"Selected Individual = %d", gWindowsSettings[CW]->SelectedElement+1);		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		gfmRenderBitmapString(-.05f,1.1f,GLUT_BITMAP_HELVETICA_12,temp);	}}void gfnhDrawAlleleFreqs(void){	int k,l;	GLfloat xs = 1.0f, ys = .5f;	int n;	GLfloat w,h,halfh;	GLfloat x, y;	int Aves = 0;	GLfloat cum0,cum1;	int CW = glutGetWindow();	char temp[200];	GLfloat WoH = gfmWoH();	clipping_struct *Clips = gWindowsSettings[CW]->Clips;	if(gWindowsSettings[CW]->GFNH_CURRENT_OR_AVES==GFNH_AVES)		Aves = 1;		gfmSetParsForBarGraphs(gC->Dat->L, gWindowsSettings[CW]->NumCols, xs, ys, &n, &w, &h);		halfh = .5f * h;		gWindowsSettings[CW]->SelectedElement = gfmBarGraphIdxFromXY(n, gC->Dat->L,  w,  h,  xs,  ys,					 gWindowsSettings[CW]->XCoord,  gWindowsSettings[CW]->YCoord);		CYCLE_l(gC->Dat)		cum0 = 0.0f;		cum1 = 0.0f;				x = gfmBarGraphXCoord(n,w,xs,l);		y = gfmBarGraphYCoord(n,h,ys,l);				// draw the locus name to the left of the locus		sprintf(temp,"%s ",gC->Dat->LocNames[l]);		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		if(l == gWindowsSettings[CW]->SelectedElement)			glColor3fv(gWindowsSettings[CW]->ColorScheme->Series[0]);  // make the selected one a different color		gfmStrokeString(temp,h,x,y-h,3,0.0f,WoH);						CYCLE_k(gC->Dat)						gfmDrawRectLeaf6f(x,y,w,halfh, cum0, 1.0f, gWindowsSettings[CW]->ColorScheme->Series[k]);			gfmDrawRectLeaf6f(x,y-halfh,w,halfh, cum1, 1.0f, gWindowsSettings[CW]->ColorScheme->Series[k]);						if(Aves)  {				cum0 += gC->Lat->Theta[0][l][k]->Ave;				cum1 += gC->Lat->Theta[1][l][k]->Ave;			}			else  {				cum0 += gC->Lat->Theta[0][l][k]->v;				cum1 += gC->Lat->Theta[1][l][k]->v;			}										END1CYCLE	END1CYCLE		if(gWindowsSettings[CW]->SelectedElement >= 0) {		sprintf(temp,"Selected Locus = %s", gC->Dat->LocNames[gWindowsSettings[CW]->SelectedElement]);		glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);		gfmRenderBitmapString(-.05f,1.1f ,GLUT_BITMAP_HELVETICA_12,temp);	}}void gfpeDrawPritchQHist(void){	int CW = glutGetWindow();	int s;	char Str[100];		int DE = gWindowsSettings[CW]->DisplayedElement;	if(DE > gC->Dat->M - 1)  {		DE = gC->Dat->M - 1;		gWindowsSettings[CW]->DisplayedElement = DE;	}	if(DE < 0)  {		DE = 0;		gWindowsSettings[CW]->DisplayedElement = DE;	}			sprintf(Str,"Displayed Individual = %d",DE+1);	glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);	gfmRenderBitmapString(-.05f,1.1f,GLUT_BITMAP_HELVETICA_18,Str);		CYCLE_s(gC->Lat->PritLat)		glColor3fv(gWindowsSettings[CW]->ColorScheme->Series[s]);		gfmduDrawOneHistAsCurveWith2Bars(gC->Lat->Ind[DE]->PritInd->Q[s],1,				GFMDU_NO_STIPPLE,0);	END1CYCLE			// then draw the axes	gfmDrawXYAxes();}void gfnhDrawAlleleFreqsHist(void){	int CW = glutGetWindow();	dval ***temp;	int k,l,a;	char Str[100];	clipping_struct *Clips = gWindowsSettings[CW]->Clips;		int DE = gWindowsSettings[CW]->DisplayedElement;		if(DE > gC->Dat->L - 1)  {		DE = gC->Dat->L - 1;		gWindowsSettings[CW]->DisplayedElement = DE;	}	if(DE < 0)  {		DE = 0;		gWindowsSettings[CW]->DisplayedElement = DE;	}		// set the number of key color items	// this is really klugie, as it is now.  SHould fix it later.	gWinDefs[5]->NumColorKeys = &(gC->Dat->Kl[DE]);		// set l, the locus subscript, to the displayed element	l=DE;		temp = (dval ***)ECA_CALLOC((size_t)2, sizeof(dval **));	temp[0] = (dval **)ECA_CALLOC((size_t)gC->Dat->Kl[l], sizeof(dval *));	temp[1] = (dval **)ECA_CALLOC((size_t)gC->Dat->Kl[l], sizeof(dval *));		sprintf(Str,"Displayed Locus = %d",DE+1);	glColor3fv(gWindowsSettings[CW]->ColorScheme->Text);	gfmRenderBitmapString(Clips->xlo + .25f * (Clips->xhi-Clips->xlo),					Clips->yhi - .15f * (Clips->yhi-Clips->ylo)					 ,GLUT_BITMAP_HELVETICA_18,Str);			CYCLE_k(gC->Dat)		CYCLE_a		temp[a][k] = gC->Lat->Theta[a][DE][k];		END1CYCLE	END1CYCLE		gfnhProbsHistogram(temp,gC->Dat->Kl[DE],2);		// then draw the axes	gfmDrawXYAxes();		free(temp[0]);	free(temp[1]);	free(temp);}/*	This draws a line curve histogram for probability quantities.			Num1 is the number of histograms in each block of them'		Num2 is the number of blocks of histograms		It uses the hist field in the dval structs, and it also plots the	current value as a vertical line at the point, under the curve.*/void gfnhProbsHistogram(dval ***D, int Num1, int Num2){	int CW = glutGetWindow();	int i,j;	GLint factor;	GLushort pattern;				// cycle through the dvals and plot the hists	for(i=0;i<Num2;i++)  { 		// add the stippling here for just i = 0 or i = 1		if(i%2==0) {			factor = 1;			pattern = 65535;  // no stipple		}		if(i%2==1)  {			factor = 3;			pattern = 43690;		}			for(j=0;j<Num1;j++)  {			gfnhDrawOneHistAsCurveWith2Bars(D[i][j],gWindowsSettings[CW]->ColorScheme->Series[j],factor,pattern,0);		}	}	}/*	draws a line, plus a bar at either end,	factor and pattern refer to the stippling	factor = 1 and stipple = 65535 is No stippling.	AsDensity = 1 means that the heights will be divided by Hist->d so that	the thing is scaled the way a density would be*/void gfnhDrawOneHistAsCurveWith2Bars(dval *D, GLfloat *C, GLint factor, GLushort pattern, int AsDensity){	int i;	hist_struct *Hist = D->Hist;	GLfloat d = (GLfloat)D->Hist->d;	GLfloat x,y,h;			// set the color	glColor3fv(C);		// draw rectangles for the bins at the ends (<= Lo and >Hi)	// draw the one at the left end first	if(AsDensity == 1)		h = (GLfloat)(Hist->H[0]/(Hist->dTot * d));	else 		h = (GLfloat)(Hist->H[0]/Hist->dTot);	glRectf((GLfloat)Hist->Lo, 0.0f, (GLfloat)(Hist->Lo - Hist->d), h );		// then the one at the right end	if(AsDensity == 1)		h = (GLfloat)(Hist->H[0]/(Hist->dTot * d));	else 		h = (GLfloat)(Hist->H[0]/Hist->dTot);	glRectf((GLfloat)Hist->Hi, 0.0f, (GLfloat)(Hist->Hi + Hist->d), h );				glEnable(GL_LINE_STIPPLE);	glLineStipple(factor,pattern);	// then draw the line	glBegin(GL_LINE_STRIP);				for(i=1;i<D->Hist->NumBins-1;i++)  {			x = d * (GLfloat)( (i-1) + i) / 2.0f;			y = (GLfloat)(Hist->H[i] / Hist->dTot);			if(AsDensity==1)				y /= d;							glVertex2f(x,y);		}	glEnd();	glDisable(GL_LINE_STIPPLE);		// then draw the vertical line showing the current value	x = (GLfloat)D->v;	if(D->v >= Hist->Hi)  {		y = (GLfloat) (Hist->H[Hist->NumBins-1] / Hist->dTot);	}	else if( (Hist->HasLeftovers==1) && D->v >= Hist->Left)  {		y = (GLfloat)(Hist->H[Hist->NumBins-2] / Hist->dTot);	}	else if(D->v <= Hist->Lo)  {		y = (GLfloat)(Hist->H[0] / Hist->dTot);	}	else {		y = (GLfloat)(Hist->H[ (int)((D->v - Hist->Lo) / d) + 1] / Hist->dTot);	}		if(AsDensity==1)		y /= d;			glBegin(GL_LINES);		glVertex2f(x,0);		glVertex2f(x,y);	glEnd();	// and that should be it}void gfnhOpenAlleleRightClickWindow(int MenuCall){	int CallingWindow = glutGetWindow();	int NewWindow;			// create the window		gfmCreateWindowByIndex(MenuCall);				// then update the color scheme and the displayed element in there,		// as well as whether or not it should draw the legend.		NewWindow = glutGetWindow();				gWindowsSettings[NewWindow]->ColorScheme = gWindowsSettings[CallingWindow]->ColorScheme;				gWindowsSettings[NewWindow]->DisplayedElement = gWindowsSettings[CallingWindow]->SelectedElement;				gWindowsSettings[NewWindow]->Legend->DrawLegend = 				gWindowsSettings[CallingWindow]->Legend->DrawLegend;	}void gfnhOpenPritchQRightClickWindow(int MenuCall){	int CallingWindow = glutGetWindow();	int NewWindow;		if(MenuCall == 0)  {  // this is the call for the histogram window		// create the window		gfmCreateWindowByIndex(12);				// then update the color scheme and the displayed element in there,		// as well as whether or not it should draw the legend.		NewWindow = glutGetWindow();				gWindowsSettings[NewWindow]->ColorScheme = gWindowsSettings[CallingWindow]->ColorScheme;				gWindowsSettings[NewWindow]->DisplayedElement = gWindowsSettings[CallingWindow]->SelectedElement;				gWindowsSettings[NewWindow]->Legend->DrawLegend = 				gWindowsSettings[CallingWindow]->Legend->DrawLegend;	}	}int main(int argcp, char **argv){		int seed1,seed2;	char File[100];	int FileNumber;	enum prior_type PiP = JEFFREYS, ThP = JEFFREYS;	double the_min = 1.0;		hyb_data *D;	hyb_prior *P;	hyb_chain *C;	/*		for(int i=0;i<100000;i++)  {		v = gengam(.5f,.06f);		printf("\n%.20e",v);		if(v <= 0.0) 			printf("   WOWOWOWOWOWOWOWOWOW!!!!");		else {			if(the_min > v)				the_min = v;			printf("  Min So Far = %.20e",the_min);		}	}	return(0);*/		printf("\nEnter a number for the desired DataFile:\n");	printf("\t0\tCutts4NewHybs.txt\n\t1\tBetterAFLPFake.txt\n\t2\tScottishKittiesForNewHybs.txt\n->");	scanf("%d",&FileNumber);		switch(FileNumber) {		case(0):			sprintf(File,"Cutts4NewHybs.txt");			break;		case(1):			sprintf(File,"BetterAFLPFake.txt");			break;		case(2):			sprintf(File,"ScottishKittiesForNewHybs.txt");			break;		default:			printf("\n\nSorry, not a valid number!  Exiting!...\n\n");			exit(1);	}					D = GetData(File);	GetGtypFreqCats(D,"GFClasses4Pritch.txt");		/*  now we can process the individual options a little bit  */	ProcessIndivOptions(D);		/* put alleles from indivs known to be in Purebred categories into the 		"PriorizedAllelesPile" */	PriorizeAllelesFromFixedZ(D);		// here, make the simulation a Pritchard type	D->TypeOfSim = PRITCHARD;		P = CreatePriors(D,PiP,ThP);		C = CreateLatentChain(D,P);// Make a learning sample from the cats collected at the vet/*if(strcmp(File,"ScottishKittiesForNewHybs.txt")==0) {UseLastFromNForPriorForZero(C, 231)//C->Dat->M = 230;} */		C->Lat->TypeOfSim = PRITCHARD;		// do the pritchard allocations, too	AllocatePritchardParts(C);	 	// allocate to the gBaumProbs array and other necessary variables for the forward-backward recursion	AllocateToMargAllocStuff(2 * C->Dat->L);					printf("\n\nGive me two small integers (>0) for random number seeds\n\n");//	scanf("%d%d",&seed1,&seed2);seed1 = 82366;seed2 = 8968756;	setall((long)seed1,(long)seed2);	InitializeChain(C);		printf("\n\nData all read and ready!!!\n\n");			// make the stupid global pointer point to where it ought to	gC = C;	// here must call glutInit from within main, with the command line option	// pointer, and then call gfmInitGFM, and that does it.  	glutInit(&argcp, argv);	gfmInitGFM();	}